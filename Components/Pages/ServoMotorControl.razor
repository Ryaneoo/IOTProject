@page "/servomotorcontrol"
@rendermode InteractiveServer
@using MQTTnet
@using MQTTnet.Client
@using MQTTnet.Client.Options
@using MQTTnet.Protocol
@using System.Security.Authentication
@inject IJSRuntime JS
@implements IAsyncDisposable
@inject LoadingBayState LoadingBayState
<PageTitle>Turn On/Off</PageTitle>

<h1 class="text-center mb-4">Servo Motor Control Panel</h1>
@if (LoadingBayState.Latest is null)
{
    <p><em>Waiting for MQTT data…</em></p>
}
else
{
    <div class="sensor-item">
        <span class="label"> Loading Bay Current Status</span>
        <span class="value">@LoadingBayState.Latest.LoadingBayStatus.ToString() </span>
    </div>
}
<div class="ac-container">
    <div class="ac-card shadow-lg p-4">

        <h4 class="text-center mb-4 text-muted">
            Select Operating Mode
        </h4>

        <div class="d-grid gap-3">

            <button class="btn btn-success btn-lg ac-btn"
                    @onclick="async () => await Activate('O')">
                Open (Servo Motor)
            </button>

            <button class="btn btn-danger btn-lg ac-btn"
                    @onclick="async () => await Activate('C')">
                 Close (Servo Motor)
            </button>

        </div>
    </div>
</div>

<script>
    @* To show if task was done*@
    function showAlert() {
        alert("Task executed successfully");
    }
</script>

@code {
    private IMqttClient? client;
    //allows subscribing to MQTT
    //initalise all variables needed for subscribing
    private const string Broker = "ab4d2e8a48a6402ca2ff5ec16a2b05a2.s1.eu.hivemq.cloud";
    private const int Port = 8883;
    private const string Topic = "tp/eng/iotp_project/grp_02/loadingbay/control";
    // _ is used so that it will be forgotten , a fire and forget method, as the remaining data is not important
    private PeriodicTimer? _timer;
    private CancellationTokenSource? _cts;
    // HiveMQ Cloud credentials
    private const string Username = "iotp_grp02";
    private const string Password = "Iotp_grp02";

    protected override async Task OnInitializedAsync() //on start to initalise

    {
        _cts = new CancellationTokenSource();
        _timer = new PeriodicTimer(TimeSpan.FromSeconds(1));

        _ = RunUiRefreshLoop(_cts.Token); //to run the refresh function to continously display new data from the MQTT via subscribing

        var factory = new MqttFactory();
        client = factory.CreateMqttClient();

        var options = new MqttClientOptionsBuilder()
            .WithClientId($"blazor-{Guid.NewGuid():N}") //unique id used to ensure a connection between devices
            .WithTcpServer(Broker, Port)// Uses the broker address and port
            .WithCredentials(Username, Password)//to access hive
            .WithCleanSession()
            .WithTls(new MqttClientOptionsBuilderTlsParameters  //allows access of using hive
            {
                UseTls = true,
                SslProtocol = SslProtocols.Tls12
            })
            .Build();

        await client.ConnectAsync(options);
    }

    private async Task Activate(char x)
    {
        if (client is null || !client.IsConnected)
            return;

        var message = new MqttApplicationMessageBuilder()
            .WithTopic(Topic)// Set your topic
            .WithPayload(x.ToString()) // Set your message payload depending on turn on or turn off

            .WithQualityOfServiceLevel(MqttQualityOfServiceLevel.AtLeastOnce) // Set QoS to 1
            .WithRetainFlag(false)  // Set retain flag
            .Build();

        await client.PublishAsync(message);   // Publish the message
        await JS.InvokeVoidAsync("showAlert");
    }
    

    private async Task RunUiRefreshLoop(CancellationToken token) //refresh function updates the page when new data has been received
    {
        while (_timer != null && await _timer.WaitForNextTickAsync(token))
        {
            await InvokeAsync(StateHasChanged);
        }
    }
    public async ValueTask DisposeAsync() //runs when the current page changes
    {
        try
        {
            if (client is not null && client.IsConnected)
                await client.DisconnectAsync(); //prevents accidental sending of message
        }
        catch { }
    }
}